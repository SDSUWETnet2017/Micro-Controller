//Project: TGS2600 Driver
//Engineer: Alven Eusantos, Jeremey Lee, Matthew Salvino
//3/13/17

// FBS
#pragma config BWRP = OFF               // Boot Segment Write Protect (Disabled) with thug life
#pragma config BSS = OFF                // Boot segment Protect (No boot flash segment)

// FGS
#pragma config GWRP = OFF               // General Segment Flash Write Protect (General segment may be written)
#pragma config GSS0 = OFF               // General Segment Code Protect (No Protection)

// FOSCSEL
#pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with Postscaler and PLL (FRCDIV+PLL))
#pragma config SOSCSRC = ANA            // SOSC Source Type (Analog Mode for use with crystal)
#pragma config LPRCSEL = HP             // LPRC Power and Accuracy (High Power/High Accuracy)
#pragma config IESO = ON                // Internal External Switch Over bit (Internal External Switchover mode enabled (Two-speed Start-up enabled))

// FOSC
#pragma config POSCMD = NONE            // Primary Oscillator Mode (Primary oscillator disabled)
#pragma config OSCIOFNC = ON            // CLKO Pin I/O Function (Port I/O enabled (CLKO disabled))
#pragma config POSCFREQ = HS            // Primary Oscillator Frequency Range (Primary Oscillator/External Clock frequency >8MHz)
#pragma config SOSCSEL = SOSCHP         // SOSC Power Selection Configuration bits (Secondary Oscillator configured for high-power operation)
#pragma config FCKSM = CSECME           // Clock Switching and Monitor Selection (Clock Switching and Fail-safe Clock Monitor Enabled)

// FWDT
#pragma config WDTPS = PS32768          // Watchdog Timer Postscale Select bits (1:32768)
#pragma config FWPSA = PR128            // WDT Prescaler bit (WDT prescaler ratio of 1:128)
#pragma config FWDTEN = SWON            // Watchdog Timer Enable bits (WDT controlled with SWDTEN bit setting)
#pragma config WINDIS = OFF             // Windowed Watchdog Timer Disable bit (Standard WDT selected (windowed WDT disabled))

// FPOR
#pragma config BOREN = BOR3             // Brown-out Reset Enable bits (Enabled in hardware; SBOREN bit disabled)
#pragma config PWRTEN = ON              // Power-up Timer Enable (PWRT enabled)
#pragma config I2C1SEL = PRI            // Alternate I2C1 Pin Mapping bit (Default SCL1/SDA1 Pins for I2C1)
#pragma config BORV = V18               // Brown-out Reset Voltage bits (Brown-out Reset at 1.8V)
#pragma config MCLRE = ON               // MCLR Pin Enable bit (RA5 input disabled; MCLR enabled)

// FICD
#pragma config ICS = PGx1               // ICD Pin Placement Select (EMUC/EMUD share PGC1/PGD1)
//#pragma config LVP = OFF

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

#define _XTAL_FREQ  8000000
#define CONSOLE_IsPutReady()        (U2STAbits.TRMT)
#define TREG2        U2TXREG
#define RREG2       U2RXREG
#define TREG1       U1TXREG
#define RREG1       U1RXREG


#include <xc.h>
#include <stdint.h>
#include <stdbool.h>
#include<p24F16KL401.h>
#include<stdio.h>
#include<stdlib.h>
#include<uart.h>
#include<string.h>

//Initialize child functions
void SendAverageAirQuality(void);
void ClearArray(void);
void GetAverage(void);
void I2CStart(void);
void getAngle(void);
void setDirection(void);
void airUART(uint16_t);
unsigned int MPH_Average(unsigned int mph_calc[120]);
void SendUART(unsigned int MPH, unsigned int gust, uint16_t ANGLE, volatile uint16_t airQuality);
void checkHighFlag();
//char *itoa(char *buffer, unsigned int i); 
float MPH_Calculate(void);
unsigned int is_gust(unsigned int mph_calc[120]);

//Radio and Console Functions//
void RadioINIT(void);
void Radio_Put(uint8_t c);
bool Radio_IsPutReady(void);
void RadioTX(char* str);
char* RadioRX(void);

void CONSOLE_PutString(char* str);
void CONSOLE_Put(uint8_t c);
void CONSOLE_INIT(void);
void __attribute__((interrupt, shadow, no_auto_psv)) _U1RXInterrupt();


//Air Quality Global Variables
int ArraySize = 100; 
int AirQualityArray[100]; //Hold 100 samples of air quality
int x = 0; //Counter for array
int Average; //Average of air quality voltage outputs
int ADCVal; //Will hold ADC Value from ADC1BUF0
int count; //Counter for getting average
int AverageAirTotal; //incremetal total for finding average air quality
int CheckAirQuality = 0;

//Global Variables Radio and Console//
int new_data = 0;
char RX_char = 0;

//Wind Vane Global Variables
uint16_t ANGLE;  
unsigned short ii;
unsigned short j;
//int AVERAGE_ANGLE;
int array_size = 250;
volatile int array_counter = 0;
int set_direction = 0; //flag goes high once all the flags are compared
int MAX = 0;

int counter = 0; //Counts to 100 for while-loop (Average_wind function)
int adder = 0;
int send_flag = 0; //Flag is high in Timer2 and sends output
int tester = 0;
    

uint16_t N_flag = 0;
uint16_t NE_flag = 0;
uint16_t E_flag = 0;
uint16_t SE_flag = 0;
uint16_t S_flag = 0;
uint16_t SW_flag = 0;
uint16_t W_flag = 0;
uint16_t NW_flag = 0;

int output_counter = 0;

//Anemometer Global VariablesN_flag
#define PI 3.14159
#define ANEMOMETER_CIRC 0.354331*PI //inches //get new anemometer circ
#define _XTAL_FREQ 8000000
#define DELAY 10000


//void getMPH(void);

volatile unsigned int pulses = 0;
//volatile unsigned int time[120] = {0};
volatile unsigned int sample_count = 0;
volatile unsigned int second_flag = 0;
volatile unsigned int calc_flag = 0;
volatile unsigned int countSpeed = 0;

//UARTSend global variables
volatile int airQualityReady;
volatile int windSpeedReady;
volatile int windDirectionReady;
volatile uint16_t airQuality;

            
void I2C_Master_Init(const unsigned long c)
{
    SSP1CON1 =0b0000000000101000; //SSPM mater node, no collision, no overflow,  Enables the serial port and configures the SDAx and SCLx pins as the serial port pins  
    SSP1CON2 =0b0000000000000000; //General Call address// Set Acknowledgment bit
    SSP1ADD = (_XTAL_FREQ/(4*c))-1; //Setting Clock Speed   (8M/4*100K)-1 = 19
    SSP1STAT =0b0000000000000000;  //Set low 
}

void I2C_Master_Wait()
{
    while ((SSP1STAT & 0x04) || (SSP1CON2 & 0x1F)); //Transmit is in progress  // Once SSP1STAT and SSP1CON2 goes high, then proceed
}


void I2C_Master_Start()
{
    I2C_Master_Wait();                 
    SSP1CON2bits.SEN = 1;             //Initiate start condition
}


 void I2C_Master_RepeatedStart()
{
    I2C_Master_Wait();
    SSP1CON2bits.RSEN = 1;           //Initiate repeated start condition
}

void I2C_Master_Stop()
{
    I2C_Master_Wait();
    SSP1CON2bits.PEN = 1;           //Initiate stop condition
}

void I2C_Master_Write(unsigned d)
{
    I2C_Master_Wait();
    SSP1BUF = d;         //Write data to SSPBUF   
}//I2C_Master_Write

void Write(unsigned a,unsigned b,unsigned c)
{
    I2C_Master_Write(a);     //slave id + 0
    I2C_Master_Write(b);    //register address
    I2C_Master_Write(c);    //data
}

unsigned short I2C_Master_Read(unsigned short a)
{
    unsigned short angle;
  
    I2C_Master_Wait();
    SSP1CON2bits.RCEN = 1; //enable receive mode for i2c
    I2C_Master_Wait();
  
  
    angle = SSP1BUF;      //Read data from SSPBUF (binary)
    I2C_Master_Wait();
  
    SSP1CON2bits.ACKDT = (a)?0:1;    //Acknowledge bit
    SSP1CON2bits.ACKEN = 1;          //Acknowledge sequence
    
        return angle;  
}//I2C_Master_Read



void Read(unsigned q,unsigned w,unsigned e)
{
    I2C_Master_Write(q); //7 bits + write
    I2C_Master_Write(w);
    I2C_Master_RepeatedStart();
    I2C_Master_Write(e); // 7 bits + read (+1)
}


void main()
{
    //Air Pollutant Sensor Pin Select
    TRISAbits.TRISA0 = 1; //Use RA0 as input
    ANSAbits.ANSA0 = 1; //Analog input = AN0
    
    //Anemometer Pin Select
    TRISBbits.TRISB15 = 1;
    ANSBbits.ANSB15 = 0;
    
    //Wind Vane Pin Select
    TRISBbits.TRISB8 = 1;      //SCL. Set as input. (SCL1) (RB8)
    TRISBbits.TRISB9 = 1;      //SDA. Set as input.  (SDA1) (RB9)
  
    AD1CON1bits.FORM = 0b00; //Output of ADC is an integer: 0b---- --xx xxxx xxxx
    AD1CON1bits.SSRC = 0b000; //Clearing SAMP bit ends sampling and begins conversion
    AD1CON1bits.ADSIDL = 1; //Discontinue operation in idle mode
    AD1CON1bits.ASAM = 0; //Sampling begins when SAMP bit is set
    
    AD1CON3bits.ADRC = 0b0; //Clock derived from system clock
    AD1CON3bits.SAMC = 0b11111; //Auto sample time bits = T_AD
    AD1CON3bits.ADCS = 0b111111;
      
    AD1CHSbits.CH0NA = 0; //Negative reference voltage at VR-
    AD1CHSbits.CH0SA = 0b0000; //Positive input select for MUXA is AN0
    
    AD1CSSL = 0; // No inputs are scanned.
    IFS0bits.AD1IF = 0; // Clear A/D conversion interrupt.
      
    U2MODEbits.UARTEN = 1;//enable UART
    U2MODEbits.USIDL = 0; // continue operation in idle mode
    U2MODEbits.STSEL = 0; // 1 stop bit
    U2MODEbits.PDSEL0 = 0;
    U2MODEbits.PDSEL1 = 0;// 8, N, 
    U2MODEbits.BRGH = 0;

    U2MODEbits.RXINV = 0;// rx idle state = 1
    U2MODEbits.ABAUD = 0;// no autobaud
    U2MODEbits.LPBACK = 0; // loopback mode disabled
    U2MODEbits.WAKE = 0; // wakeup disable
    U2MODEbits.UEN0 = 0;
    U2MODEbits.UEN1 = 0;
    U2MODEbits.RTSMD = 1;// rts mode 
    U2MODEbits.IREN = 0;// irda disabled
    U2STAbits.ADDEN = 0; // address mode disabled
      
    U2STAbits.URXISEL0 = 1;
    U2STAbits.URXISEL1 = 1; // interrupt any data received
    
    U2STAbits.UTXEN = 1; // transmit enabled
    U2STAbits.UTXBRK = 0; // break disabled
    
    U2STAbits.UTXISEL0 = 1;
    U2STAbits.UTXISEL1 = 0; // interrupt when txregister becomes empty
     
    U2BRG = 51 ; // 3.340277778
    
    T2CONbits.TMR2ON = 1; //Turn on Timer 2
    T2CONbits.T2CKPS0 = 1; //Set prescaler to 16
    T2CONbits.T2CKPS1 = 1;
    PR2 = 10050;   //(2/Fosc)*post*pre_(PR2+1) = Time   (2/8M)*16*(31250+1) = 2 sec
    
    T3CON = 0b0000000010000101;
    TMR3 = 0;
    
    T4CONbits.T4OUTPS0 = 1; //Postscaler 16
    T4CONbits.T4OUTPS1 = 1;
    T4CONbits.T4OUTPS2 = 1;
    T4CONbits.T4OUTPS3 = 1;
    T4CONbits.T4CKPS = 0b10; //prescaler 16
    T4CONbits.TMR4ON = 1; //on
    PR4 = 65535;
    TMR4 = 0;
    
    INTCON1bits.NSTDIS = 1; //Disable nested interrupts
    IPC1bits.T2IP = 0b110;
    IPC3bits.AD1IP = 0b111;
    IPC6bits.T4IP = 0b100;
    IFS0bits.T2IF = 0; //Clear Timer2 interrupt flag
    IFS1bits.T4IF = 0; //clear timer 4 flag
    
    IEC0bits.T2IE = 1; //Enable Timer2 interrupt
    IEC1bits.T4IE = 1; //enable timer 4 interrupt 

    I2C_Master_Init(100000);
    
    unsigned int MPH[120] = {0};
    unsigned int mphAverage = 0;
    unsigned int gust = 0;
    while (1)
    { 
        
        if(windDirectionReady != 1)
        {
            I2CStart();
        }
        
        if(calc_flag == 1)
        {
           MPH[countSpeed] = MPH_Calculate();
           countSpeed++;
           calc_flag = 0;
        }
        if(countSpeed == 3) //119 for 10 minutes
        {
            windSpeedReady = 1;
            mphAverage = MPH_Average(MPH);
            gust = is_gust(MPH);
            countSpeed = 0;
            memset(MPH, 0, sizeof MPH);
        }
        if((airQualityReady == 1) && (windSpeedReady == 1) && (windDirectionReady==1))
        {
            SendUART(mphAverage, gust, ANGLE, airQuality);
        }
    }
}

void I2CStart()
{
    //if(send_flag == 1) //Enters if-statement after timer2 sets flag high (every 2 seconds)
    // {
    
   
    I2C_Master_Start(); //start 
    I2C_Master_Wait(); //wait
    Read(0x80,0xFE,0x81); //MSB angle address write device address, internal address, and device add + 1 
    
    ii = I2C_Master_Read(0); //Read the MSB i2c Value
    
    I2C_Master_Wait();
    I2C_Master_Stop();  
    //send_flag == 0;
    
    getAngle();
    
    
  }




void getAngle()
{
    if(send_flag == 1)
    {
            ANGLE = ii;  //set i2c value to ANGLE (do i need this?)
            //ANGLE =(i<<6)+(j&0x3F); //Store MSB and LSB i2c values together into one variable (i2c values)
            if(array_counter < array_size)   //array_size is set to 100 samples (set to 300 samples for 10 min)    
            {
               // i2c value is compared to 8 min and max ranges for each direction
                if(((ANGLE<0x90) && (ANGLE>=0x79)) || ((ANGLE<0x81) && (ANGLE>=0x70)))   
                {
                    N_flag++;
                }
                else if((ANGLE<0x70) && (ANGLE>=0x50))  
                {
                    NE_flag++;
                }
                else if((ANGLE<0x50) && (ANGLE>=0x30))   
                {
                    E_flag++;
                }
                else if((ANGLE<0x30) && (ANGLE>=0x10))  
                {
                    SE_flag++;
                }
                else if(((ANGLE<=0xFE) && (ANGLE>=0xF0)) || ((ANGLE<=0x10) && (ANGLE>=0x01)) || (ANGLE==0xFF))   
                {
                    S_flag++;
                }
                else if((ANGLE<0xF0) && (ANGLE>=0xD0))   
                {
                    SW_flag++;
                }
                else if((ANGLE<0xD0) && (ANGLE>=0xB0))   
                {
                    W_flag++;
                }
                else if((ANGLE<0xB0) && (ANGLE>=0x90))   
                {
                    NW_flag++; //Increments flag if ANGLE is in this area
                }
                array_counter++; //counter goes until 300 samples have been made
           
            }//if(array_counter < array_size)  
            
    } //if(send_flag == 1)
    


    setDirection();
}

void setDirection()
{
    if(array_counter >= array_size) //Enter if-statement once all the samples have been set to a direction flag   
        {
            array_counter = 0; //empty array counter so it can sample again
            // Set up each flag to a char N or to hexadecimal number
            //Count which flag has the most counts
            if(N_flag > MAX) MAX = N_flag; 
            if(NE_flag > MAX) MAX = NE_flag;
            if(E_flag > MAX) MAX = E_flag;
            if(SE_flag > MAX) MAX = SE_flag;
            if(S_flag > MAX) MAX = S_flag;
            if(SW_flag > MAX) MAX = SW_flag;
            if(W_flag > MAX) MAX = W_flag;
            if(NW_flag > MAX) MAX = NW_flag;
                    
            set_direction = 1; //Increments to 10 samples and then can enter 2nd if-statement
            
            checkHighFlag();
        }
    
}


void checkHighFlag()
    {
    if(set_direction == 1) //10 samples so now check which flag is the highest
    {
       if(MAX == N_flag) ANGLE = 0x80; //0x80 //float = 
                    else if(MAX == NE_flag) ANGLE = 96; //0x60 
                    else if(MAX == E_flag) ANGLE = 64; //0x40
                    else if(MAX == SE_flag) ANGLE = 32; //0x20
                    else if(MAX == S_flag) ANGLE = 0xff; //0xFF //float = 255
                    else if(MAX == SW_flag) ANGLE = 223; //0xDF //float = 128;
                    else if(MAX == W_flag) ANGLE = 191; //0xBF
                    else if(MAX == NW_flag) ANGLE = 159; //0x9F
                    
                    else 
                        ANGLE = 0; //If an error, send zero
                    
        //prepareForUART(ANGLE);
        
       if (output_counter == 250)
        {
            windDirectionReady = 1;
        }
        output_counter++;
        set_direction = 0;
        send_flag = 0;
        

        }       

}//void I2CStart()

void __attribute__((__interrupt__,no_auto_psv)) _T2Interrupt(void)
{
    if(IFS0bits.T2IF == 1)
    {
        if(airQualityReady != 1)
        {
        
            if(CheckAirQuality > 30) //30000 for 10 min
            {
                int delay = 0;
                IFS0bits.AD1IF = 0;
                IEC0bits.AD1IE = 1; // Enable A/D conversion interrupt
                AD1CON1bits.ADON = 1; // Turn on A/D
                AD1CON1bits.SAMP = 1; // Start sampling the input
                while(delay < 10000)
                {
                    delay++;
                }
                AD1CON1bits.SAMP = 0; // End A/D sampling and start conversion
                CheckAirQuality = 0;
            }
            else
            {
                CheckAirQuality++;
            }
        }
        if(windDirectionReady != 1)
        {
            if(counter>=714) //Delay transmitting output if PR2 is not long enough //30000 or 25000
            {
                send_flag = 1; //Set flag high to output data
                IFS0bits.T2IF = 0; //Empty flag to exit Timer2
                counter = 0;
            }
            else
            {
                counter++;
            }
        }
    }
    IFS0bits.T2IF = 0;
}

void __attribute__((__interrupt__,no_auto_psv)) _T4Interrupt(void)
{
    if(windSpeedReady != 1)
    {
        if(IFS1bits.T4IF == 1)
        {
            second_flag++;
            if(second_flag == 76)
            {
                pulses = TMR3/3;
                //time[sample_count] = 4 * (sample_count + 1);
                sample_count++;
                calc_flag = 1;

                TMR3 = 0;
                second_flag = 0;
            } 
        }
    }
    IFS1bits.T4IF = 0;
}


void __attribute__ ((__interrupt__,no_auto_psv)) _ADC1Interrupt(void)
{   
    if(IFS0bits.AD1IF == 1)
    {
    if(x < ArraySize)
        {
            AirQualityArray[x] =  ADC1BUF0;
            x++;
        }
        else if(x >= ArraySize)
        {
            GetAverage();
        }   
    }
    IFS0bits.AD1IF = 0;
}

void GetAverage()
{
    count = 1;
    AverageAirTotal = 0;
    Average = 0;
    while (count < ArraySize)
    {        
            AverageAirTotal = AirQualityArray[count] + AirQualityArray[count -1];
            count++;            
    }
    Average = AverageAirTotal/ArraySize;
    airUART(Average);
}


void airUART(uint16_t Quality)
{
    if(Quality <= 124)
        {
            airQuality = 0x0001;
        }
        else if(Quality < 217 && Quality >= 124)
        {
            airQuality = 0x0010;
        }
        else if(Quality < 321 && Quality >= 217)
        {
            airQuality = 0x0100;
        }
        else if(Quality >= 321)
        {
            airQuality = 0x1000;
        }
    airQualityReady = 1;
}


void ClearArray()
{
    int i = 0;
    while(i <= ArraySize-1)
    {
        AirQualityArray[i] = 0;
        i++;
    }
    x = 0;
}


float MPH_Calculate(void)
{
    float RPM = 0;

    RPM = pulses * 60;
    RPM /= 12;
    RPM *= 60;
    RPM *= 1.11;
    return RPM/5280; //conversion
}

unsigned int MPH_Average(unsigned int mph_calc[120])
{
    int average = 0;
    int i = 0;
    for (i = 0; i < countSpeed; i++)
    {
        average += mph_calc[i];
    }
    return average/i;
}

unsigned int is_gust(unsigned int mph_calc[120])
{
    unsigned int max = mph_calc[0];
    int i = 0;
    for (i = 1; i < 120; i++)
    {
        if(mph_calc[i] > max)
        {
            max = mph_calc[i];
        }
    }
    return max;
}

void SendUART(unsigned int MPH, unsigned int gust, uint16_t ANGLE, volatile uint16_t airQuality)
{
    IEC0bits.T2IE = 0; //disable Timer2 interrupt
    IEC1bits.T4IE = 0; //disable timer 4 interrupt
    IEC0bits.AD1IE = 0;
    char superNodeID = '1'; //start bit
    int print=0;
    char send[18] = {0};
    //Used for testing
    /*unsigned int MPHsend = 12;
    unsigned int ANGLEsend = 11;
    unsigned int airQualitysend = 10;*/
    /*char directionString[8];
    char speedString[8];
    char airString[8];
    char gustString[8];*/
    char END = '7';
    sprintf(send, "%c %04x %02x %02x %02x %c\r\n", superNodeID, airQuality, ANGLE, MPH, gust, END);
    while(print < 20)
    {
        if(U2STAbits.UTXBF == 0)
        {
            WriteUART2(send[print]);
            print++;
        }
    }
   /*if(U2STAbits.UTXBF == 0) //check for empty buffer
    {
        WriteUART2(superNodeID);
    }
   //itoa(airString, airQualitysend);
    sprintf(airString, " %04X ", airQuality);
   while(print < 6)
    {
        if(U2STAbits.UTXBF == 0)
        {
            WriteUART2(airString[print]);
            print++;
        }
    }
    print = 0;
    //itoa(directionString, ANGLEsend);
    sprintf(directionString, "%02X ", ANGLE);
     while(print < 3)
    {
        if(U2STAbits.UTXBF == 0)
        {
            WriteUART2(directionString[print]);
            print++;
        }
    }
    print = 0;
   
    //itoa(speedString, MPHsend);
    sprintf(speedString, "%02X ", MPH);
    while(print < 3)
    {
        if(U2STAbits.UTXBF == 0)
        {
            WriteUART2(speedString[print]);
            print++;
        }
    }
    print = 0;
    sprintf(gustString, "%02X ", gust);
    while(print < 3)
    {
        if(U2STAbits.UTXBF == 0)
        {
            WriteUART2(gustString[print]);
            print++;
        }
    }
    print = 0;
    
    while(print == 0)
    {
        if(U2STAbits.UTXBF == 0)
        {
            WriteUART2(END);
            print++;
        }
    }*/
    ClearArray(); //clears air quality array
    airQualityReady = 0; //flags reset
    windDirectionReady = 0;
    windSpeedReady = 0;
    set_direction = 0;
    send_flag = 0;
    ANGLE = 0; // CLEAR THE DIRECTION
    MAX = 0; //CLEAR THE MAX FLAG
    N_flag = 0;
    NE_flag = 0;
    E_flag = 0;
    SE_flag = 0;
    S_flag = 0;
    SW_flag = 0;
    W_flag = 0;
    NW_flag = 0; //CLEAR ALL FLAGS
    
    
    output_counter = 0; //resets wind vane sample counter
    IEC0bits.T2IE = 1; //Enable Timer2 interrupt
    IEC1bits.T4IE = 1; //enable timer 4 interrupt
    
}
/*
 char *itoa(char *buffer, unsigned int i) 
 {
    unsigned int n;
    unsigned int negate = 0;
    int c = 2; //6
 
    if (i < 0) 
    {
        negate=1;
        n = -i;
    } 
    else if (i == 0) 
    {    
        buffer[0] = '0';
        buffer[1] = 0;
        return buffer;
    } 
    else 
    {
        n = i;
    }
    buffer[c--] = 0;
    do 
    {
        buffer[c--] = (n % 10) + '0';
        n = n / 10;
    } while (n);
    if (negate) 
    {
        buffer[c--] = '-';
    }
    return &buffer[c+1];
 }
 */
